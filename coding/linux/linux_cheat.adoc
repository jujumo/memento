= image:icon_linux.svg["X", width=64px] Linux cheat code
:toc:

== Do for all files

.#!/bin/bash
[source,bash]
----
find . -name \*.txt -type f -print0 | xargs -0 -n1 -I {} echo "{}"
----

.find:
 - `-name \*.txt` Its filename must end with .txt
 - `-type f` Only search for files (not folders)
 - `-print0` separate found file names with ASCII NULL character.

.xargs
 - `-0` receive ASCII NULL character.
 - `-n1` process received arguments one at a time
 - `-I {}` will replace occurrences of `{}` in command by the actual argument.


=== Search within files

-- source : https://www.everythingcli.org/find-exec-vs-find-xargs/

.#!/bin/bash
[source,bash]
----
find . -name \*.txt -type f -print0 | xargs -0 grep -Hn '$USER'
----

 - `find .` find all files, folders, symlinks, etc in the current directory recursively
 - `-name \*.txt` Its filename must end with .txt
 - `-type f` Only search for files (not folders)
 - `-print0` and `-0` use ASCII NULL character.
 - `-H` Always print filename headers with output lines.
 - `-n` Each output line is preceded by its relative line number in the file, starting at line 1.


== usefull commands

=== grep
search into files of current working dir:

.#!/bin/bash
[source,bash]
grep -r PATTERN

 - `-r` :

=== xargs

 - `-p` : *print* & *prompt* the user to run it
 - `-I %` : This replaces occurrences of the argument with the argument passed to xargs (`%` in that case).

.#!/bin/bash
[source,bash]
cat /etc/passwd | xargs -I % echo "### % ###"

=== diff

.#!/bin/bash
[source,bash]
diff <(ls new_dir) <(old_dir)

=== awk



.basics 1
[cols="1m,4e"]
|===
|Command |

| $1
| Reference first column

| awk '/pattern/ {action}' file
| Execute action for matched pattern `pattern` on file `file`

| ;
| Char to separate two actions

| print
| Print current record line

| $0
| Reference current record line

| FS
| Field separator of input file (default whitespace)

| NF
| Number of fields in current record

| NR
| Line number of the current record


| ^
| Match beginning of field

| ~
| Match opterator

| !~
| Do not match operator

| -F
| Command line option to specify input field delimiter

| BEGIN
| Denotes block executed once at start

| END
| Denotes block executed once at end

| str1 str2
| Concat str1 and str2
|===




=== sed


.usage
[source,bash]
----
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...
...
----


=== rename bunch of files

requires : rename, parallel, find


rename all files with `.match` extension to `.matches`.

.example
[source,bash]
----
find ./ -iname "*.match" -print0 | parallel -j8 rename -v 's/.match/.matches/' {}
----


=== parallel
do parallel tasks

.Convert all *.wav to *.mp3
[source,bash]
parallel lame {} -o {.}.mp3 ::: *.wav

see link:parallel.adoc[parallel]

=== watch

execute a command or program periodically

.#!/bin/bash
[source,bash]
watch -d ifconfig

- `-d` highlights the changes in the command output.


=== expect
command talks to other interactive programs

.script.sh
[source,expect]
----
#!/usr/bin/expect -f
spawn ssh debian@192.168.7.2
expect "debian@192.168.7.2's password:"
send "temppwd\r"
set prompt_re {\$ $}
expect -re $prompt_re
send "mkdir -p emma && cd emma\r"
expect -re $prompt_re
interact
----


=== CSV

Nicely display a CSV file, with columns aligned.

[source,bash]
cat data.csv | perl -pe 's/((?<=,)|(?<=^)),/ ,/g;' | column -t -s, | less -S

Make an alias into `.bashrc`.

.ubuntu alias
[source,bash]
----
function pretty_csv {
    column -t -s, -n "$@" | less -F -S -X -K
}
----

-- see source for more details : https://www.stefaanlippens.net/pretty-csv.html[stefaanlippens]


=== disk usage

.#!/bin/bash
[source,expect]
----
du -h . | sort -h -r | head -n 10
----

- `du -h` :for human readable format,
- add `du -s` to display only a total for each argument,
- `sort -h` : tells sort it is human readable format,
- `sort -r` : tells reverse sort.
